// Fill out your copyright notice in the Description page of Project Settings.

#include "ProceduralRoom.h"

#include "AITypes.h"
#include "PickableItem.h"
#include "Spot.h"
#include "GC_UE4CPP/Game/MainGameMode.h"
#include "GC_UE4CPP/Game/MainGameState.h"

// Sets default values
AProceduralRoom::AProceduralRoom()
{
	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;

	// Creates InstancedStaticMeshComponents for the floor and walls, sets their mobility and set the collisions
	InstancedStaticMeshComponentFloor = CreateDefaultSubobject<UInstancedStaticMeshComponent>(
		TEXT("Instanced Floor Static Mesh"));
	SetRootComponent(InstancedStaticMeshComponentFloor);

	InstancedStaticMeshComponentFloor->SetMobility(EComponentMobility::Static);
	InstancedStaticMeshComponentFloor->SetCollisionProfileName("BlockAll");


	InstancedStaticMeshComponentWall = CreateDefaultSubobject<UInstancedStaticMeshComponent>(
		TEXT("Instanced Wall Static Mesh"));

	InstancedStaticMeshComponentWall->SetMobility(EComponentMobility::Static);
	InstancedStaticMeshComponentWall->SetCollisionProfileName("BlockAll");

	// Generates FActorSpawnParameters for spawning objects
	SpawnInfo.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::DontSpawnIfColliding;
}

// Called when the game starts or when spawned
void AProceduralRoom::BeginPlay()
{
	// Generates the offset of the floor based on the wanted size
	// Also generates the half size of the floor tiles for wall offset
	Super::BeginPlay();
	FloorHalfSize = (FloorSize % 2 == 0) ? FloorSize / 2 : FloorSize / 2 + 1;
	HalfTile = TileableFloorAndWallSize / 2;

	AMainGameMode* MainGameMode = Cast<AMainGameMode>(GetWorld()->GetAuthGameMode());
	if (MainGameMode)
	{
		MainGameMode->GameModeBeginPlayFinished.AddUObject(this, &AProceduralRoom::Spawn);
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT("Failed to cast GetAuthGameMode() to AMainGameMode"))
	}
}

void AProceduralRoom::Spawn()
{
	// Spawns all of the needed components for the room 
	SpawnRoom();
	SpawnBarrels(Barrel, Food);
	SpawnCrates(CrateClump2, CrateClumpSize, ChanceOfCrateClump, SpawnHeight, 90);
	SpawnCrates(CrateClump, CrateClumpSize, ChanceOfCrateClump, SpawnHeight, 0);
	SpawnCrates(CrateClass, CrateSize, ChanceOfSmallCrate, SpawnHeight, 0);
}

void AProceduralRoom::SpawnRoom()
{
	// Generate the floor with a random rotation and generates the walls
	for (int i = -FloorHalfSize; i <= FloorHalfSize; i++)
	{
		for (int j = -FloorHalfSize; j <= FloorHalfSize; j++)
		{
			int RandNum = FMath::RandRange(0, 3);
			int angle = 0;
			switch (RandNum)
			{
			case 1:
				angle = 90;
				break;
			case 2:
				angle = 180;
				break;
			case 3:
				angle = 270;
				break;
			default:
				break;
			}

			if (i == -FloorHalfSize || i == FloorHalfSize)
			{
				if (i == -FloorHalfSize)
				{
					SpawnWall(i, j, -HalfTile, 0, HalfTile, 90);
					SpawnWall(i, j, -HalfTile, 0, HalfTile * 3, 90);
				}
				else
				{
					SpawnWall(i, j, +HalfTile, 0, HalfTile, 90);
					SpawnWall(i, j, +HalfTile, 0, HalfTile * 3, 90);
				}
			}
			if (j == -FloorHalfSize || j == FloorHalfSize)
			{
				if (i != 0 && i != 1)
				{
					if (j == -FloorHalfSize)
					{
						SpawnWall(i, j, 0, -HalfTile, HalfTile, 0);
						SpawnWall(i, j, 0, -HalfTile, HalfTile * 3, 0);
					}
					else
					{
						SpawnWall(i, j, 0, +HalfTile, HalfTile, 0);
						SpawnWall(i, j, 0, +HalfTile, HalfTile * 3, 0);
					}
				}
			}
			InstancedStaticMeshComponentFloor->AddInstance(FTransform(FRotator(0, angle, 0),
			                                                          FVector(i * TileableFloorAndWallSize,
			                                                                  j * TileableFloorAndWallSize, 0)));
		}
	}
}

void AProceduralRoom::SpawnWall(int I, int J, int IOffset, int JOffset, int height, int Rotation)
{
	// Spawns the walls with juste the variables, needless repeat of code otherwise
	InstancedStaticMeshComponentWall->AddInstance(FTransform(FRotator(0, Rotation, 0),
	                                                         FVector(I * TileableFloorAndWallSize + IOffset,
	                                                                 J * TileableFloorAndWallSize + JOffset, height)));
}

void AProceduralRoom::SpawnCrates(UClass* CrateToSpawn, int ActorSize, int SpawnChance, float Height, int Rotation)
{
	// Spawns the crates, it could be a single crate 
	
	float Ratio = TileableFloorAndWallSize / ActorSize; //Calculate the ratio of the grid generated by the floor to match the size for the generation of the boxes. For example 12 floor tiles are longer, or shorter, than 12 of the spawned actors

	int Size = FloorSize * Ratio; // Calculates the actual grid size for the crates

	int HalfSpawnSize = (Size % 2 == 0) ? Size / 2 : Size / 2 + 1; // Calculates the offset for centering the room at the 0,0 coords

	for (int i = -HalfSpawnSize + 1; i < HalfSpawnSize; ++i)
	{
		for (int j = -HalfSpawnSize + 1; j < HalfSpawnSize; ++j)
		{
			int ChanceOfSpawn = FMath::RandRange(0, 100); // Gives the chance of spawning for each spot on the "grid"

			if (ChanceOfSpawn <= SpawnChance)
			{
				AActor* SpawnedActor = GetWorld()->SpawnActor<AActor>(CrateToSpawn,
				                                                      FVector(i * ActorSize, j * ActorSize, Height),
				                                                      FRotator(0, Rotation, 0), SpawnInfo);
				if (SpawnedActor)
				{
					SpawnedActor->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepWorldTransform);
				}
			}
		}
	}
}

void AProceduralRoom::SpawnBarrels(UClass* PrmBarrel, UClass* PrmFood)
{
	// Generate randomly a first barrel/spot with food on it 
	int XSpawn;
	int YSpawn;
	int Rotation;

	ASpot* ABarrel = nullptr;
	while (!ABarrel)
	{
		XSpawn = FMath::RandRange(-FloorHalfSize, FloorHalfSize);
		YSpawn = FMath::RandRange(-FloorHalfSize, FloorHalfSize);

		Rotation = FMath::RandRange(0, 360);
		ABarrel = GetWorld()->SpawnActor<ASpot>(
			PrmBarrel, FVector(XSpawn * TileableFloorAndWallSize, YSpawn * TileableFloorAndWallSize, SpawnHeight),
			FRotator(0, Rotation, 0), SpawnInfo);
	}

	if (ABarrel)
	{
		ABarrel->SetSpotOccupied();
		APickableItem* AFood = GetWorld()->SpawnActor<APickableItem>(
			PrmFood, ABarrel->GetFoodSpotTransform().GetLocation(), ABarrel->GetFoodSpotTransform().Rotator());
		AFood->SetOnGroundPhysics(true);
	}
	
	AMainGameState* MainGameState = Cast<AMainGameState>(GetWorld()->GetGameState());

	if (MainGameState)
	{
		MainGameState->AddSpotToArray(ABarrel); // Adds the spawned barrel/spot to the list of spots in the game state
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT("Failed to cast GetGameState() to AMainGameState"))
	}


	// Generates the number of barrel/spot asked in NumberOfBarrels minus the first on that is spawned above
	for (int i = 0; i < NumberOfBarrels - 1; ++i)
	{
		Rotation = FMath::RandRange(0, 360);
		XSpawn = FMath::RandRange(-FloorHalfSize, FloorHalfSize);
		YSpawn = FMath::RandRange(-FloorHalfSize, FloorHalfSize);


		ABarrel = GetWorld()->SpawnActor<ASpot>(
			PrmBarrel, FVector(XSpawn * TileableFloorAndWallSize, YSpawn * TileableFloorAndWallSize, SpawnHeight),
			FRotator(0, Rotation, 0), SpawnInfo);

		if (!ABarrel)
		{
			i--; // if the barrel/spot couldn't spawn due to collision with an other barrel/spot decrements the counter value to spawn an other
		}
		else
		{
			if (MainGameState)
			{
				MainGameState->AddSpotToArray(ABarrel); // Adds the spawned barrel/spot to the list of spots in the game state
			}
			else
			{
				UE_LOG(LogTemp, Error, TEXT("Failed to cast GetGameState() to AMainGameState"))
			}
		}
	}
	
#if WITH_EDITOR
	GEngine->AddOnScreenDebugMessage(1, 5.0f, FColor::Blue, TEXT("Spawn Barrels"));
#endif
	
}
